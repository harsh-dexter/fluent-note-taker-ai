
/**
 * API service for the Meeting Note-Taker application
 * This service handles all communication with the backend API
 */

// This is a mock implementation that would be replaced with real API calls
// when connecting to a backend server
const BASE_URL = "/api";

// Types
export interface Meeting {
  id: string;
  filename: string;
  uploadDate: string;
  status: "processing" | "completed" | "error";
  language?: string;
  duration?: string;
  summary?: string;
  actionItems?: ActionItem[];
  error?: string;
}

export interface ActionItem {
  id: string;
  description: string;
  assignee?: string;
  dueDate?: string;
}

export interface TranscriptSegment {
  id: string;
  speakerId: string;
  speakerName?: string;
  startTime: number;
  endTime: number;
  text: string;
  language?: string;
}

export interface SearchResult {
  segmentId: string;
  text: string;
  matchPositions: [number, number][];
}

// Mock data factory functions
const createMockMeeting = (id: string, status: Meeting["status"]): Meeting => ({
  id,
  filename: `meeting-${id}.mp3`,
  uploadDate: new Date(Date.now() - Math.random() * 10000000000).toISOString(),
  status,
  language: Math.random() > 0.5 ? "English" : "Spanish",
  duration: `${Math.floor(Math.random() * 120) + 10}:${Math.floor(Math.random() * 60)
    .toString()
    .padStart(2, "0")}`,
  summary: status === "completed" ? "This is a sample meeting summary that would be generated by the AI." : undefined,
  actionItems: status === "completed" ? [
    { id: "1", description: "Follow up with the team about project timeline", assignee: "John Doe" },
    { id: "2", description: "Schedule the next planning meeting", assignee: "Jane Smith" },
    { id: "3", description: "Prepare quarterly report", assignee: "Alex Johnson" },
  ] : undefined,
  error: status === "error" ? "Error processing audio file" : undefined
});

const createMockTranscript = (meetingId: string): TranscriptSegment[] => {
  const speakerNames = ["John", "Jane", "Alex", "Sarah"];
  const transcriptLength = Math.floor(Math.random() * 20) + 10;
  const segments: TranscriptSegment[] = [];
  
  let currentTime = 0;
  for (let i = 0; i < transcriptLength; i++) {
    const speakerIndex = Math.floor(Math.random() * speakerNames.length);
    const duration = Math.floor(Math.random() * 30) + 5;
    
    segments.push({
      id: `${meetingId}-segment-${i}`,
      speakerId: `speaker-${speakerIndex}`,
      speakerName: speakerNames[speakerIndex],
      startTime: currentTime,
      endTime: currentTime + duration,
      text: `This is a sample transcript segment from ${speakerNames[speakerIndex]}. It would contain the actual words spoken during the meeting.`,
      language: Math.random() > 0.2 ? "English" : "Spanish"
    });
    
    currentTime += duration;
  }
  
  return segments;
};

// Mock API functions
const mockMeetings: Meeting[] = [
  createMockMeeting("1", "completed"),
  createMockMeeting("2", "processing"),
  createMockMeeting("3", "completed"),
  createMockMeeting("4", "error"),
  createMockMeeting("5", "completed")
];

const mockTranscripts: Record<string, TranscriptSegment[]> = {
  "1": createMockTranscript("1"),
  "3": createMockTranscript("3"),
  "5": createMockTranscript("5")
};

// API Functions
export const api = {
  // Upload a meeting audio file
  uploadMeeting: async (file: File, onProgress?: (progress: number) => void): Promise<Meeting> => {
    // Simulate upload progress
    let progress = 0;
    const interval = setInterval(() => {
      progress += 10;
      if (progress <= 100 && onProgress) {
        onProgress(progress);
      }
      if (progress > 100) {
        clearInterval(interval);
      }
    }, 500);
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 5000));
    clearInterval(interval);
    
    // Create new mock meeting
    const newMeeting: Meeting = {
      id: `${mockMeetings.length + 1}`,
      filename: file.name,
      uploadDate: new Date().toISOString(),
      status: "processing",
    };
    
    mockMeetings.push(newMeeting);
    return newMeeting;
  },
  
  // Get all meetings
  getMeetings: async (): Promise<Meeting[]> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 800));
    return [...mockMeetings];
  },
  
  // Get a single meeting by ID
  getMeeting: async (id: string): Promise<Meeting> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const meeting = mockMeetings.find(m => m.id === id);
    if (!meeting) {
      throw new Error(`Meeting with ID ${id} not found`);
    }
    
    return { ...meeting };
  },
  
  // Get transcript for a meeting
  getTranscript: async (meetingId: string): Promise<TranscriptSegment[]> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const transcript = mockTranscripts[meetingId];
    if (!transcript) {
      throw new Error(`Transcript for meeting ${meetingId} not found`);
    }
    
    return [...transcript];
  },
  
  // Search within a meeting transcript
  searchTranscript: async (meetingId: string, query: string): Promise<SearchResult[]> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 700));
    
    const transcript = mockTranscripts[meetingId];
    if (!transcript) {
      throw new Error(`Transcript for meeting ${meetingId} not found`);
    }
    
    // Simple search implementation
    const results: SearchResult[] = [];
    const lowerQuery = query.toLowerCase();
    
    transcript.forEach(segment => {
      const lowerText = segment.text.toLowerCase();
      const matches: [number, number][] = [];
      
      let startPos = 0;
      while (startPos < lowerText.length) {
        const matchPos = lowerText.indexOf(lowerQuery, startPos);
        if (matchPos === -1) break;
        
        matches.push([matchPos, matchPos + lowerQuery.length]);
        startPos = matchPos + 1;
      }
      
      if (matches.length > 0) {
        results.push({
          segmentId: segment.id,
          text: segment.text,
          matchPositions: matches
        });
      }
    });
    
    return results;
  },
  
  // Export meeting summary as PDF
  exportMeetingReport: async (meetingId: string): Promise<Blob> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // In a real implementation, this would call a backend API that generates
    // and returns a PDF file. For now, we'll just return a mock blob.
    return new Blob(['Dummy PDF content'], { type: 'application/pdf' });
  }
};
